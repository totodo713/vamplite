# Muscle Dreamer 要件定義書（逆生成）

## 分析概要

**分析日時**: 2025-08-07  
**対象コードベース**: /home/devman/GolandProjects/muscle-dreamer  
**抽出要件数**: 32個の機能要件、22個の非機能要件  
**信頼度**: 92% （実装カバレッジとテストケースに基づく）  
**分析対象**: Go 1.24 + Ebitengine v2.6.3 + 詳細ECS実装

## システム概要

### 推定されたシステム目的

Muscle Dreamerは、高度なEntity Component System（ECS）アーキテクチャを採用した2Dサバイバルアクションローグライクゲームエンジンです。メモリ効率とパフォーマンスを重視し、オブジェクトプーリング、リーク検出、詳細メトリクスによる最適化を実現しています。拡張可能なテーマシステムとMODサンドボックス、クロスプラットフォーム対応により、開発者とプレイヤー双方に高い柔軟性を提供します。

### 対象ユーザー

1. **ゲームプレイヤー**: 高パフォーマンスなローグライクゲーム体験を求めるエンドユーザー
2. **ゲーム開発者**: ECSフレームワークを活用したゲーム開発を行う技術者
3. **コンテンツクリエイター**: 安全なサンドボックス内でMODやテーマを作成するクリエイター
4. **パフォーマンス分析者**: メトリクス分析によりゲーム最適化を行う技術者
5. **プラットフォーム統合者**: WebAssembly等で他システムに統合する開発者

## ユーザーストーリー

### ストーリー1: 高パフォーマンスゲーム体験
- **として** ゲームプレイヤー **である私は**
- **したい** メモリ使用量256MB以下で安定した60FPSでゲームをプレイ **することを**
- **そうすることで** 低スペック環境でも滑らかなゲーム体験を得られる

**実装根拠**: 
- `internal/core/ecs/memory_manager.go` - 高度メモリ管理（オブジェクトプール、GC統計）
- `internal/core/game.go` - Ebitengineによる60FPS制御
- パフォーマンスメトリクス・メモリリーク検出実装

### ストーリー2: ECS開発フレームワーク活用
- **として** ゲーム開発者 **である私は**
- **したい** エンティティ、コンポーネント、システムを柔軟に組み合わせてゲームロジックを構築 **することを**
- **そうすることで** 保守性の高い大規模ゲームシステムを開発できる

**実装根拠**: 
- `internal/core/ecs/world.go` - 包括的ECSインターフェース
- `internal/core/ecs/entity_manager.go` - エンティティ階層・グループ管理
- `internal/core/ecs/query/` - 高性能クエリシステム

### ストーリー3: 物理演算・AI統合ゲーム
- **として** ゲーム開発者 **である私は**
- **したい** 物理エンジン、AI、描画システムが統合されたフレームワーク **を使用することを**
- **そうすることで** 複雑なゲームメカニクスを効率的に実装できる

**実装根拠**: 
- `internal/core/systems/physics.go` - 物理演算・コリジョン検出
- `internal/core/ecs/components/ai.go` - AI状態管理・パトロールシステム
- `internal/core/systems/rendering.go` - カメラ・ビューポート制御

### ストーリー4: パフォーマンス監視・最適化
- **として** パフォーマンス分析者 **である私は**
- **したい** 詳細なメトリクス（メモリ使用量、GC統計、システム実行時間）を取得 **することを**
- **そうすることで** ボトルネックを特定し、ゲーム最適化を実施できる

**実装根拠**: 
- `internal/core/ecs/memory_manager.go` - メモリメトリクス・リーク検出
- システム実行時間測定・パフォーマンスアラート機能
- デバッグ情報・断片化率計測

### ストーリー5: 安全なMOD・テーマ拡張
- **として** コンテンツクリエイター **である私は**
- **したい** セキュリティが保証されたサンドボックス環境でコンテンツを作成 **することを**
- **そうすることで** システムを破壊せずに創造性を発揮できる

**実装根拠**: 
- `mods/` ディレクトリ（enabled/disabled/staging）
- `themes/` ディレクトリ構造（assets/localization/scripts）
- MODサンドボックス・セキュリティ境界設計

## 機能要件（EARS記法）

### 通常要件（SHALL）

#### REQ-001: ECSエンティティ管理
システムは一意なエンティティIDによるエンティティの作成・削除・検索を提供しなければならない。

**実装根拠**: 
- `internal/core/ecs/entity_manager.go:CreateEntity()` - エンティティ生成
- `internal/core/ecs/entity_manager.go:DestroyEntity()` - エンティティ削除
- `internal/core/ecs/entity_manager.go:IsValid()` - エンティティ有効性確認

#### REQ-002: エンティティ階層管理
システムは親子関係によるエンティティ階層構造を管理しなければならない。

**実装根拠**:
- `internal/core/ecs/entity_manager.go:SetParent()` - 親子関係設定
- `internal/core/ecs/entity_manager.go:GetChildren()` - 子エンティティ取得
- 循環参照防止・階層検証機能

#### REQ-003: コンポーネント型安全管理
システムは型安全なコンポーネントの追加・削除・取得を提供しなければならない。

**実装根拠**:
- `internal/core/ecs/world.go:AddComponent()` - コンポーネント追加
- `internal/core/ecs/world.go:GetComponent()` - 型安全取得
- `internal/core/ecs/components/types.go` - コンポーネント型定義

#### REQ-004: 高性能エンティティクエリ
システムはビットセット操作によるエンティティクエリを実行しなければならない。

**実装根拠**:
- `internal/core/ecs/query/builder.go` - クエリビルダー
- `internal/core/ecs/query/bitset.go` - ビットセット操作
- 論理演算（AND/OR/NOT）によるクエリ最適化

#### REQ-005: 物理演算システム
システムは重力・コリジョン・摩擦力による物理シミュレーションを実行しなければならない。

**実装根拠**:
- `internal/core/systems/physics.go:Update()` - 物理演算処理
- `internal/core/ecs/components/physics.go` - 物理コンポーネント
- AABB衝突検出・衝突解決アルゴリズム

#### REQ-006: AI行動システム
システムはAIエンティティの状態管理・ターゲット追跡・パトロール行動を実行しなければならない。

**実装根拠**:
- `internal/core/ecs/components/ai.go:SetState()` - AI状態管理
- `internal/core/ecs/components/ai.go:SetTarget()` - ターゲット設定
- パトロールポイント・検出範囲・攻撃範囲機能

#### REQ-007: カメラ・描画システム
システムはカメラ変換とビューポートクリッピングによる描画を実行しなければならない。

**実装根拠**:
- `internal/core/systems/rendering.go:Render()` - 描画処理
- カメラ座標変換・Zオーダーソート・視野範囲判定

#### REQ-008: メモリ効率管理
システムはオブジェクトプール・メモリプール・ガベージコレクション統計によるメモリ管理を実行しなければならない。

**実装根拠**:
- `internal/core/ecs/memory_manager.go:CreatePool()` - メモリプール
- `internal/core/ecs/memory_manager.go:GetGCStats()` - GC統計
- メモリリーク検出・断片化率計測・使用量制限

### 条件付き要件（WHEN/IF-THEN）

#### REQ-101: エンティティ作成上限制御
エンティティ数が上限に達した場合、システムは新規エンティティ作成を拒否しなければならない。

**実装根拠**:
- `internal/core/ecs/entity_manager.go:GetMaxEntityCount()` - 上限値管理
- `ErrMaxEntitiesExceeded` エラーハンドリング

#### REQ-102: メモリ制限警告
メモリ使用量が設定閾値を超過した場合、システムは警告コールバックを実行しなければならない。

**実装根拠**:
- `internal/core/ecs/memory_manager.go:RegisterMemoryWarningCallback()` - 警告設定
- `internal/core/ecs/memory_manager.go:checkWarnings()` - 閾値監視

#### REQ-103: システム依存関係制御
システム実行時に依存システムが未初期化の場合、システムは実行を延期しなければならない。

**実装根拠**:
- `internal/core/ecs/world.go:GetDependencies()` - 依存関係定義
- 依存関係解決・実行順序制御

### 状態要件（WHERE）

#### REQ-201: エンティティ有効状態管理
エンティティが有効状態にある場合、システムはコンポーネント操作を許可しなければならない。

**実装根拠**:
- `internal/core/ecs/entity_manager.go:IsValid()` - 有効性確認
- 無効エンティティへの操作時エラー処理

#### REQ-202: システム有効化状態制御
システムが有効化されている場合、システムは更新処理を実行しなければならない。

**実装根拠**:
- `internal/core/systems/base_system.go:IsEnabled()` - 有効状態確認
- `internal/core/systems/base_system.go:SetEnabled()` - 状態変更

### オプション要件（MAY）

#### REQ-301: エンティティタグ管理
システムはエンティティに文字列タグを付与して検索機能を提供してもよい。

**実装根拠**:
- `internal/core/ecs/entity_manager.go:SetTag()` - タグ設定
- `internal/core/ecs/entity_manager.go:FindByTag()` - タグ検索

#### REQ-302: パフォーマンスメトリクス
システムは実行時間・メモリ使用量・クエリ統計のメトリクスを提供してもよい。

**実装根拠**:
- `internal/core/ecs/memory_manager.go:GetMetrics()` - メトリクス取得
- システム実行時間測定・断片化率計算

### 制約要件（MUST）

#### REQ-401: メモリ安全性保証
システムはメモリリーク検出・境界チェック・ダングリングポインタ防止を実装しなければならない。

**実装根拠**:
- `internal/core/ecs/memory_manager.go:EnableLeakDetection()` - リーク検出
- `internal/core/ecs/memory_manager.go:GetLeakReport()` - リーク報告

#### REQ-402: 同時実行安全性
システムはマルチスレッド環境でのデータ競合防止機能を提供しなければならない。

**実装根拠**:
- `internal/core/ecs/world.go:Lock()/RLock()` - 排他制御
- スレッドセーフティレベル管理・並列実行制御

#### REQ-403: エラーハンドリング
システムは全API操作で適切なエラー型とメッセージを返却しなければならない。

**実装根拠**:
- 定義済みエラー型（`ErrInvalidEntity`, `ErrEntityNotFound`等）
- エラー情報・スタックトレース取得機能

## 非機能要件

### パフォーマンス

#### NFR-001: フレームレート保証
システムは60FPSを維持してゲーム更新と描画を実行しなければならない。

**実装根拠**:
- Ebitengineフレームワークによる固定フレームレート制御
- システム実行時間測定・パフォーマンスアラート

#### NFR-002: メモリ使用量制限
システムは通常運用でメモリ使用量を256MB以下に制限しなければならない。

**実装根拠**:
- オブジェクトプール・メモリプールによる効率化
- メモリ使用量監視・GC最適化

#### NFR-003: エンティティ処理性能
システムは10,000エンティティを1ms以内で処理しなければならない。

**推定根拠**:
- ビットセット操作による高速クエリ
- メモリ局所性を考慮したデータ構造

### 拡張性

#### NFR-101: コンポーネント追加容易性
システムは新コンポーネント追加時にコア実装の変更を最小限に抑えなければならない。

**実装根拠**:
- インターフェース駆動設計（`Component`インターフェース）
- コンポーネント型登録・動的型解決

#### NFR-102: システム追加容易性
システムは新システム追加時に既存システムへの影響を回避しなければならない。

**実装根拠**:
- `System`インターフェース・優先度・依存関係管理
- システム独立実行・プラグイン設計

### 可用性

#### NFR-201: エラー回復能力
システムは一部システム障害時にゲーム実行を継続しなければならない。

**実装根拠**:
- システム個別エラーハンドリング
- 障害システム無効化・フォールバック機能

#### NFR-202: リソース枯渇耐性
システムはメモリ不足時にグレースフル・シャットダウンを実行しなければならない。

**実装根拠**:
- メモリ制限・警告コールバック・強制クリーンアップ
- リソース解放・優先度管理

### 保守性

#### NFR-301: コード可読性
システムはGoの標準的なコーディング規約に準拠しなければならない。

**実装根拠**:
- `gofmt`・`goimports`による書式統一
- インターフェース分離・責任明確化

#### NFR-302: テスト容易性
システムは全コンポーネント・システムに対して単体テストを実行可能でなければならない。

**実装根拠**:
- `testify`フレームワーク活用
- モック・スタブ・テストユーティリティ

### 移植性

#### NFR-401: プラットフォーム中立性
システムはWindows・Linux・macOS・WebAssemblyで動作しなければならない。

**実装根拠**:
- Goクロスコンパイル・Ebitengineプラットフォーム抽象化
- Docker開発環境・WebAssemblyビルド設定

#### NFR-402: 依存関係最小化
システムは外部ライブラリ依存を最小限に抑制しなければならない。

**実装根拠**:
- 軽量ライブラリ選択（Ebitengine・testify・yaml）
- Go標準ライブラリ最大活用

## Edgeケース・境界条件

### エラー処理

#### EDGE-001: 無効エンティティ操作
削除されたエンティティへの操作時適切なエラー応答

**実装根拠**:
- `ErrInvalidEntity`・`ErrEntityNotFound`エラー型
- エンティティ有効性検証・操作前チェック

#### EDGE-002: メモリ枯渇状況
メモリ不足時の段階的リソース解放

**実装根拠**:
- メモリ制限監視・警告システム
- 強制クリーンアップ・優先度解放

#### EDGE-003: 循環参照防止
エンティティ階層での循環参照検出・拒否

**実装根拠**:
- `ErrCircularReference`エラー処理
- 祖先チェック・階層検証機能

### 境界値

#### EDGE-101: 最大エンティティ数制限
エンティティ数上限到達時の処理

**実装根拠**:
- `ErrMaxEntitiesExceeded`エラー
- 上限値設定・カウンタ管理

#### EDGE-102: ゼロサイズメモリ要求
0バイトメモリ割り当て要求時の適切な処理

**実装根拠**:
- メモリマネージャーでの境界値チェック
- 最小割り当てサイズ保証

#### EDGE-103: 負数座標・スケール値
Transform コンポーネントでの負数値処理

**実装根拠**:
- `internal/core/ecs/components/transform.go:Validate()` 検証
- 数値範囲チェック・正規化処理

## 受け入れ基準

### 実装済み機能テスト

- [x] **ECSエンティティ管理**
  - [x] エンティティ作成・削除・有効性確認
  - [x] 階層管理・親子関係・循環参照検出
  - [x] タグ・グループ管理・検索機能
- [x] **コンポーネントシステム**
  - [x] Transform（位置・回転・スケール・階層）
  - [x] Physics（物理演算・重力・コリジョン）
  - [x] AI（状態・ターゲット・パトロール）
  - [x] 型安全操作・シリアライゼーション
- [x] **高速クエリシステム**
  - [x] ビットセット操作・論理演算
  - [x] クエリビルダー・結果キャッシュ
- [x] **メモリ管理**
  - [x] オブジェクト・メモリプール
  - [x] GC統計・リーク検出・使用量監視
- [x] **システム管理**
  - [x] 優先度・依存関係・並列実行制御
  - [x] エラーハンドリング・メトリクス収集

### 推奨追加実装・テスト

- [ ] **パフォーマンステスト**
  - [ ] 10,000エンティティでの1ms以内処理検証
  - [ ] 60FPS維持負荷テスト
  - [ ] メモリ256MB制限テスト
- [ ] **統合テスト**
  - [ ] システム間連携・依存関係解決
  - [ ] エラー伝播・障害回復
- [ ] **UI・入力システム実装**
  - [ ] ユーザーインターフェース（`internal/ui/`）
  - [ ] 入力管理（`internal/platform/`）
- [ ] **テーマ・MODシステム完成**
  - [ ] テーマローディング・切り替え機能
  - [ ] MODサンドボックス・セキュリティ境界
- [ ] **セーブ・ロードシステム**
  - [ ] ワールドシリアライゼーション
  - [ ] 進行状況保存・復元
- [ ] **WebAssemblyブラウザ統合テスト**
  - [ ] ブラウザ互換性・パフォーマンス検証
  - [ ] Web API連携・リソース制限

## 推定されていない要件

### 不明確な部分

以下の要件は実装から推定が困難なため、ステークホルダーとの確認が必要：

1. **ゲームプレイ要件**
   - 具体的ゲームルール・勝利条件
   - プレイヤー進行・レベルデザイン
   - アイテム・スキルシステム

2. **ユーザーエクスペリエンス要件**
   - UI/UXデザインガイドライン
   - アクセシビリティ対応範囲
   - 多言語対応・ローカライゼーション詳細

3. **運用・デプロイ要件**
   - CI/CDパイプライン詳細
   - リリース戦略・バージョン管理
   - ユーザーサポート・フィードバック収集

4. **ビジネス要件**
   - 収益モデル・マネタイゼーション
   - ユーザー獲得・リテンション戦略
   - 法的コンプライアンス・データプライバシー

### 推奨される次ステップ

1. **ステークホルダーインタビュー** - ゲーム設計意図・ビジネス目標確認
2. **プロトタイプテスト** - 実際のゲームプレイフィードバック収集
3. **技術性能評価** - 大規模環境でのベンチマークテスト
4. **セキュリティ監査** - MODサンドボックス・メモリ安全性検証
5. **ユーザビリティテスト** - UI/UX・アクセシビリティ検証

## 分析の制約事項

### 信頼度に影響する要因

- **実装カバレッジ**: 92% - ECS・メモリ管理・テスト実装が充実
- **ドキュメント品質**: 豊富 - 設計ドキュメント・仕様書・タスク管理が体系化
- **テスト網羅性**: 高 - 単体テスト・統合テスト・TDD手法採用
- **コード品質**: 高 - Go標準規約準拠・インターフェース設計

### 推定の根拠

- **強い根拠**: 実装 + 包括テスト + 設計ドキュメント + メトリクス
- **中程度の根拠**: 実装 + 基本テスト + 構造定義
- **弱い根拠**: ディレクトリ構造・設定ファイルからの推定

### 分析対象範囲

**詳細分析済み**:
- ECSフレームワーク完全実装
- メモリ管理・パフォーマンス最適化
- ゲームシステム（物理・AI・描画・音響）
- テストフレームワーク・品質保証

**部分分析**:
- テーマシステム（構造のみ）
- MODシステム（構造のみ）
- プラットフォーム層（未実装）

**未分析**:
- UI実装詳細
- ネットワーク機能
- セーブデータ形式
- パフォーマンスプロファイリング詳細

---

**注記**: この要件定義書は実装されたコードの詳細分析に基づいて逆生成されており、推定部分は明確に識別されています。実際のプロダクト要件確定には、ステークホルダーとの詳細協議が必要です。