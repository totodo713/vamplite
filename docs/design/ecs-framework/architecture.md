# ECSフレームワーク アーキテクチャ設計

## システム概要

Muscle DreamerのECS（Entity Component System）フレームワークは、高性能なゲームエンジンのコアとして設計されます。このフレームワークは10,000以上のエンティティを60FPSで処理し、モジュラーなゲーム開発とMODサポートを実現します。

## アーキテクチャパターン

### パターン: Data-Oriented Design + ECS Architecture
**選択理由:**
- **パフォーマンス最適化**: CPU キャッシュフレンドリーなメモリレイアウト
- **スケーラビリティ**: 大規模エンティティ数への対応
- **拡張性**: 新機能・MODの安全な追加が可能
- **保守性**: コンポーネントとシステムの分離による明確な責任境界

### 設計原則
1. **データ指向設計**: 構造体の配列（SoA: Structure of Arrays）によるメモリ効率最適化
2. **インターフェース分離**: 各システムが必要な機能のみに依存
3. **並行処理対応**: goroutineによる独立システムの並列実行
4. **型安全性**: Goの型システムを活用したコンパイル時チェック

## コンポーネント構成

### コアモジュール

#### 1. Entity Manager (`internal/core/ecs/entity.go`)
- **責任**: EntityID生成・管理、エンティティライフサイクル
- **実装方式**: スパースセット + ジェネレーション番号による高速検索
- **パフォーマンス目標**: 1フレームで1,000エンティティ作成

#### 2. Component Store (`internal/core/ecs/component.go`)
- **責任**: コンポーネントデータの効率的格納・取得
- **実装方式**: 型別コンポーネントプールによるメモリ局所性向上
- **メモリ効率**: 1エンティティあたり100バイト以下のオーバーヘッド

#### 3. System Manager (`internal/core/ecs/system.go`)
- **責任**: システム実行順序制御・並列実行管理
- **実装方式**: 依存グラフによる自動スケジューリング
- **実行性能**: 10,000エンティティ・50システムを10ms以内で処理

#### 4. Query Engine (`internal/core/ecs/query.go`)
- **責任**: 条件指定によるエンティティ高速検索
- **実装方式**: ビットマスク + インデックスによるO(1)検索
- **検索性能**: 10,000エンティティから1ms以内で結果取得

### フレームワーク層

#### Memory Pool Manager (`internal/core/ecs/memory.go`)
- **メモリ再利用**: オブジェクトプールによるGC負荷軽減
- **断片化防止**: エンティティIDの再利用戦略
- **リーク検出**: 未使用エンティティの自動削除

#### Security Sandbox (`internal/mod/ecs_api.go`)
- **MODアクセス制御**: 制限されたECS API の提供
- **権限管理**: 読み取り専用・書き込み制限の段階的権限
- **検証機能**: 不正操作の検出・防止

## テクノロジースタック

### 言語・フレームワーク
- **言語**: Go 1.22
- **ゲームエンジン**: Ebitengine v2.6.3
- **並行処理**: Goroutines + sync パッケージ
- **テストフレームワーク**: Go標準 testing + testify

### パフォーマンス最適化技術
- **メモリレイアウト**: SoA（Structure of Arrays）によるキャッシュ効率向上
- **並列処理**: 独立システムのgoroutine並列実行
- **プリフェッチ**: 次フレーム処理対象の事前ロード
- **バッチ処理**: 同種コンポーネントの一括更新

### 型安全性・エラーハンドリング
- **ジェネリクス**: Go 1.18+の型パラメータによる型安全なコンポーネント管理
- **インターフェース**: 抽象化による実装詳細の隠蔽
- **エラーハンドリング**: context.Context による統一的なエラー伝播

## セキュリティ・保守性

### MODサンドボックス設計
- **API制限**: 公開インターフェースのみアクセス可能
- **メモリ保護**: 直接メモリアドレス操作の禁止
- **実行時間制限**: システム実行タイムアウトによる無限ループ防止

### 監視・デバッグ機能
- **パフォーマンス計測**: フレーム時間・メモリ使用量の詳細トラッキング
- **エンティティ可視化**: 開発環境でのリアルタイム状態表示
- **エラーロギング**: 構造化ログによる問題特定支援

## スケーラビリティ戦略

### 垂直スケーリング
- **最適化**: プロファイリング主導のボトルネック解消
- **並列化**: CPUコア数に応じたシステム並列実行
- **メモリ効率**: ゼロアロケーション設計によるGC負荷軽減

### 水平スケーリング
- **分散システム**: 将来的なマルチプレイヤー対応の考慮
- **コンポーネント分離**: ネットワーク同期可能な設計
- **状態管理**: immutableデータ構造による状態一貫性

## 実装優先度

### Phase 1: コア機能（必須）
1. EntityManager - エンティティ基本操作
2. ComponentStore - 基本コンポーネント管理
3. SystemManager - システム実行制御
4. QueryEngine - 基本クエリ機能

### Phase 2: 最適化（パフォーマンス要件達成）
1. メモリプール実装
2. 並列処理最適化
3. キャッシュ効率改善
4. プロファイリング・計測機能

### Phase 3: 拡張機能（オプション要件）
1. シリアライゼーション機能
2. デバッグ・可視化ツール
3. MODサンドボックス強化
4. 実行時システム追加・削除

## パフォーマンス目標

| 指標 | 目標値 | 測定方法 |
|------|--------|----------|
| エンティティ作成 | 1,000個/フレーム | ベンチマークテスト |
| コンポーネント検索 | 10,000個から1ms | クエリ性能テスト |
| システム実行 | 全体で10ms以下 | フレーム時間計測 |
| メモリオーバーヘッド | 100バイト/エンティティ | メモリプロファイリング |
| 同時エンティティ数 | 10,000個@60FPS | 負荷テスト |

## 品質保証

### テスト戦略
- **単体テスト**: 各モジュール95%以上のカバレッジ
- **統合テスト**: システム間の相互作用検証
- **パフォーマンステスト**: 目標値達成の継続的検証
- **ストレステスト**: 限界負荷での安定性確認

### 継続的改善
- **プロファイリング**: 定期的な性能ボトルネック特定
- **ベンチマーク**: リグレッション防止のための性能測定
- **メトリクス収集**: 実行時パフォーマンスデータの蓄積